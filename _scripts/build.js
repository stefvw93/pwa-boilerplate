const { execSync } = require("child_process");
const { paths } = projectConfig;
const colors = require("colors");
const fs = require("fs");
const path = require("path");
const projectConfig = require("../project.config");

// build command joined by 'then'
const buildCommand = [
  // clear compiled and pre-dist folders
  `rm -rf ${paths.pre_distribution} ${paths.compiled}`,
  "tsc",
  `webpack --config ${paths.webpack}/webpack.production --display-error-details`
].join(" && ");

/**
 * Execute build
 */
console.log(`${colors.green.bold("Compiling production...")}`);
if (process.env.API_URL) {
  console.log(`${colors.green.bold("API URL: ")} ${process.env.API_URL}`);
}

execSync(buildCommand, { stdio: "inherit" });

/**
 * create a distribution folder if it does not exist yet
 */
const distExists = fs.existsSync(paths.distribution);
if (!distExists) {
  fs.mkdirSync(paths.distribution);
}

/**
 * Check file names and content hashes to determine if distribution should be replaced by new build.
 *
 * This is done to prevent overwriting of build files when it's not necessary.
 * If we do unnecessary overwrites, the client browser will download the
 * bundle again as the file seems to have changed - because of updated ETag, date modified, etc.
 *
 * If we keep the original file when the content has not changed, the client browser
 * should be using a cached version, which will improve initial load time.
 */

// get the filenames of the files generated by webpack
const builtFiles = fs.readdirSync(paths.pre_distribution);

// get the filenames of the previously build, or create an empty array if there are none
const distributedFiles = distExists ? fs.readdirSync(paths.distribution) : [];

// copy new files and delete old files if necessary
builtFiles.forEach(preFilename => {
  const isHTML = preFilename.indexOf("html") > -1;

  if (distributedFiles.length === 0) {
    /**
     * if there's no dist files yet, move all the built files to distribution
     */
    const src = path.join(paths.pre_distribution, preFilename);
    const dest = path.join(paths.distribution, preFilename);

    fs.copyFileSync(src, dest);
  } else {
    /**
     * compare and copy the built and dist files
     */
    distributedFiles.forEach(distFilename => {
      // compare and copy, force for index.html
      compareAndCopy(distFilename, preFilename, isHTML);
    });
  }
});

function compareAndCopy(original, by, forceCopy = false) {
  const a = original.split(".");
  const b = by.split(".");
  const src = path.join(paths.pre_distribution, by);
  const dest = path.join(paths.distribution, by);

  /**
   * Compare name and hash.
   *
   * Webpack output filenames are like main.203948sadf034fasdf.js.
   * so fragment 0 should be the name and fragment 1 should be the hash.
   *
   * if the name is the same, but the hash is different,
   * copy the new file and remove the old
   */
  if (forceCopy) {
    fs.copyFileSync(src, dest);
  } else if (a[0] === b[0] && a[1] !== b[1]) {
    /**
     * Name is the same, but content hash is different.
     * This means the particular file should be replaced in distribution.
     */
    fs.unlinkSync(path.join(paths.distribution, original));
    fs.copyFileSync(src, dest);
  } else {
    if (a[0] === b[0]) console.log("Content hash not changed", original);
  }
}
